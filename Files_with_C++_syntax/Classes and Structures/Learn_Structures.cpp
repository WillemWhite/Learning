#include <iostream>
/* Чтобы не передавать каждую переменную по отдельности
был создан такой тип данных, как структура, который 
является пользовательским типом данных */

// рассмотрим пример объявления структуры

#pragma pack(push, 1) //для выравнивания в 1 байт.
struct Employee /* да, имена принято называть с большой буквы, 
чтобы отличать от обычных переменных */
{
    // данные элементы называются членами структуры, или же "полями структуры"
    short id; 
    int age;
    double salary = 1.0; /* возможность нестатическим членам структуры 
    присваивать значения по умолчанию(нестатическая инициализация членов) */
}; // не забывай прописывать эту дрянь
#pragma pack(pop)

/* большим преимуществом использования структур, нежели отдельных переменных, 
являетсявозможность передать всю структуру в функцию, 
которая должна работать с её членами: */

struct Point3d
{
    double x;
    double y;
    double z;
};

/* также функция может возвращать структуру (что является одним из немногих 
случаев, когда она может возвращать сразу несколько переменных */

Point3d getZeroPoint()
{
    Point3d temp = { 0.0, 0.0, 0.0 }; // temporary - временный
    return temp;
}

void printInformation(Employee employee)
{
    std::cout << "ID: " << employee.id << "\n";
    std::cout << "Age: " << employee.age << "\n";
    std::cout << "Salary: " << employee.salary << "\n";
}

// рассмотрим ещё вложенные структуры
struct Company 
{
    Employee CEO; // Employee - это структура внутри структуры Company
    int numberOfEmpoloyees;
};

int main(int argc, char *argv[])
{
    Employee john; // создаем отдельную структуру Employee для John-a
    john.id = 8; // выбор члена (.) обращается к отдельным членам структуры
    john.age = 27;
    john.salary = 32.17;

    Employee james;
    james.id = 9; // работают кстати также, как и обычные переменные
    james.age = 27; //применимы обычные арифметические и операции сравнения
    james.salary = 32.17;
    
    // а теперь рассмотрим более простой способ инициализации структур
    Employee ann = { 5, 27, 35000.0 }; /* ann.id = 5, ann.age = 27, 
    ann.salary = 35000.0, это называется uniform-инициализацией, 
    доступно только с C++11 */
    Employee jack = { 6, 25 }; /* в данном случае для последнего члена 
    будет применено значение по умолчанию (если ранее оно не задано, 
    то будет присвоен 0)*/

    printInformation(john);

    std::cout << "\n";

    printInformation(ann);

    std::cout << "\n";

    Point3d zero = getZeroPoint();

    if (zero.x == 0.0 && zero.y == 0.0 && zero.z == 0.0)
        std::cout << "The point is zero\n";
    else 
        std::cout << "The point isn't zero\n";
    
    Company myCompany;

    /* myCompany.CEO.salary - таким образом бы узнали какая зарплата у СЕО, 
    то есть используем оператор выбора членов дважды соответственно сначала
    выбор поля СЕО, как из структуры myCompany, а затем поле salary из 
    структуры Employee */

    myCompany = {{ 3, 35, 5590.0 }, 4 }; /* есть возможность использования 
    вложенных списков инициализаторов с вложенными структурами */

    printInformation(myCompany.CEO);

    static double smth = 9.8; /* smth - статическая глобальная переменная и
    её можно использовать только в этом файле программы */
    // extern же используется для внешней глобальной переменной, нужно доизучить

    std::cout << "The size of Employee is " << sizeof(Employee) << "\n";

    std::cin.get();
    
    return 0;
}
